/**
 * Classic clearfix mixin, based on: http://nicolasgallagher.com/micro-clearfix-hack
 * @return {css} 
 */
.clearfix(){
 *zoom: 1; /* IE6, IE7 */
	&:before, &:after{ content: " "; display: table; }
	&:after{ clear: both; }
}
.clearfix { .clearfix(); } // Use :extend(.clearfix all);


/**
 * Handle margin between child elements generally
 * @param  {dimension} @margin: 1em           How much margin top will be applied
 * @return {css}          
 */
.inner(@margin: 1em){
	> * {
		margin-top: @margin;
		&:first-child { margin-top: 0; }
	}
}
.inner { .inner(); } // Use :extend(.inner all);


/**
 * Hide elements visually, keeping them accessible for screenreaders
 * @return {css}
 */
.sr-only () {
	position: absolute !important;
	clip: rect(1px 1px 1px 1px); /* IE6, IE7 */
	clip: rect(1px, 1px, 1px, 1px);
	padding:0 !important;
	border:0 !important;
	height: 1px !important;
	width: 1px !important;
	overflow: hidden;
}
.sr-only { .sr-only(); } // Use :extend(.sr-only all);


/**
* text-shadow-mixin with IE8/9 fallback
* @param  {px}    @x:              0px           x offset
* @param  {px}    @y:              0px           y offset
* @param  {px}    @spread:         8px           spread
* @param  {color} @shadowColor:    #000          color of the shadow
* @param  {color} @fontColor:      #000          font color
* @return {css}               
*/
.textshadow(@x: 0px,@y: 0px,@spread: 8px,@shadowColor: #000,@fontColor: #000) {
	@blur: round(unit(@spread) * 0.75);
	@xOff: @x - (@blur * 1.75);
	@yOff: @y - (@blur * 1.1);

	display: block; position: relative; text-shadow: @x @y @spread @shadowColor;

	.no-textshadow & {
		[data-textshadow] {
			display: block; margin: @yOff 0 0 @xOff; color: @shadowColor;
			-ms-filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=@blur);
			filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=@blur);
			&:before { display: block; content: attr(data-textshadow); position: absolute; top: auto; bottom: auto; left: auto; right: auto; margin: (@yOff * -1) 0 0 (@xOff * -1); width: 100%; color: @fontColor; text-align: inherit; }
		}
	}
}

/**
 * For staggered/delayed transitions
 * @param  {number} @delay The delay between each step
 * @param  {number} @max Maximum elements that get delayed. Any elements beyond limit get the delay of the last element
 * @param  {string} @selector Optional child selector
 * @param  {number} @index Starting point of the loop, do not pass this parameter.
 * @return {css}
 */
.stagger(@delay: 50, @max: 5, @selector: ~'', @index: 0) when (@index < @max) {

	// Set transition delay
	&:nth-child(@{index})@{selector}{
		transition-delay: @delay * @index + 0ms;
	}

	// Trigger loop
	.stagger(@delay, @max, @selector, (@index + 1));
}
.stagger(@delay: 50, @max: 5, @selector: ~'', @index: 0) when (@index >= @max){

	// Delay elements beyond max
	&:nth-child(n+@{index})@{selector}{
		transition-delay: @index * @delay  + 0ms;
	}
}

/**
 * For staggered/delayed transitions beginning with
 * the last element and staggering backwards
 * @param  {number} @delay The delay between each step
 * @param  {number} @max Maximum elements that get delayed. Any elements beyond limit get the delay of the last element
 * @param  {string} @selector Optional child selector
 * @param  {number} @index Starting point of the loop, do not pass this parameter.
 * @return {css}
 */
.backStagger(@delay: 50, @max: 5, @selector: ~'', @index: 1) when (@index < @max) {

	// Set transition delay
	&:nth-last-child(@{index})@{selector}{
		transition-delay: @delay * @index + 0ms;
	}

	// Trigger loop
	.backStagger(@delay, @max, @selector, (@index + 1));
}
.backStagger(@delay: 50, @max: 5, @selector: ~'', @index: 0) when (@index >= @max){

	// Delay elements beyond max
	&:nth-last-child(n+@{index})@{selector}{
		transition-delay: @index * @delay  + 0ms;
	}
}